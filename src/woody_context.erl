%%% @doc Client API
%%% @end

-module(woody_context).

-include("woody_defs.hrl").

%% API
-export([new/3, new/4]).
-export([next/1]).

-export([extend/2]).
-export([get_ext/1, get_ext/2]).

-export([get_rpc_id/1, get_child_rpc_id/1]).
-export([get_rpc_id/2, get_child_rpc_id/2]).

-export([set_ev_handler/2]).
-export([get_ev_handler/1]).

-export([make_rpc_id/3]).
-export([new_id/1]).
-export([unique_int/0]).

%% Types
-export_type([ctx/0]).
-export_type([ext/0]).
-export_type([ext_name/0]).
-export_type([is_root/0]).

-type ctx() :: #{  %% The elements are madatory if not specified otherwise
    root_rpc      => boolean(),
    seq           => non_neg_integer(),
    rpc_id        => woody_t:rpc_id(),
    child_rpc_id  => woody_t:rpc_id(), %% optional
    extension     => ext(),            %% optional
    event_handler => woody_t:handler()
}.
-type ext()       :: #{binary() => binary()}.
-type ext_name()  :: binary().
-type is_root()   :: boolean().

-define(ROOT_REQ_PARENT_ID, <<"undefined">>).
-define(DEFAULT_ID_SUFFIX,  <<"">>).


%%
%% API
%%
-spec new(is_root(), woody_t:req_id() | woody_t:rpc_id() | undefined, woody_t:handler()) ->
    ctx().
new(IsRoot, Id, EvHandler) ->
    new(IsRoot, Id, EvHandler, undefined).

-spec new(is_root(), woody_t:req_id() | woody_t:rpc_id() | undefined, woody_t:handler(), ext() | undefined) ->
    ctx().
%% `is_root` defines if the next RPC is going to be a root RPC.
%% - If it is (`is_root` = true), then `req_id`/`rpc_id` defines both:
%%   `rpc_id` and `child_rpc_id`.
%% - Otherwise (`is_root` = false), `rpc_id` actually defines the _parent_ RPC
%%   and will be used to generate consequent `child_rpc_id`s for next RPCs.
new(false, RpcId = #{}, EvHandler, Ext) ->
    make_ctx(false, RpcId, EvHandler, Ext);
new(true, RpcId = #{parent_id := ?ROOT_REQ_PARENT_ID}, EvHandler, Ext) ->
    make_ctx(true, RpcId, EvHandler, Ext);
new(true, undefined, EvHandler, Ext) ->
    %% This is going to be a root RPC with autogenerated RpcId
    RootId = new_id(?DEFAULT_ID_SUFFIX),
    make_ctx(
        true,
        make_rpc_id(?ROOT_REQ_PARENT_ID, RootId, RootId),
        EvHandler,
        Ext
    );
new(true, ReqId, EvHandler, Ext) ->
    make_ctx(
        true,
        make_rpc_id(?ROOT_REQ_PARENT_ID, ReqId, ReqId),
        EvHandler,
        Ext
    ).

-spec next(ctx()) -> ctx().
next(Context = #{root_rpc := true, rpc_id := RpcId}) ->
    Context#{child_rpc_id => RpcId};
next(Context = #{root_rpc := false, seq := 0,
    rpc_id := #{span_id := SpanId, trace_id := TraceId}}
) ->
    NextSeq = 1,
    Context#{
        seq => NextSeq,
        child_rpc_id => make_rpc_id(SpanId, TraceId, new_id(genlib:to_binary(NextSeq)))
    };
next(Context = #{root_rpc := false, seq := Seq,
    child_rpc_id := #{parent_id := ParentId, trace_id := TraceId}}
) ->
    NextSeq = Seq + 1,
    Context#{
        seq => NextSeq,
        child_rpc_id => make_rpc_id(ParentId, TraceId, new_id(genlib:to_binary(NextSeq)))
    }.


-spec extend(ctx(), ext()) ->
    ctx().
extend(Context, Ext) ->
    Context#{extension => append_ext(get_ext(Context), Ext)}.

-spec get_ext(ctx()) ->
    ext().
get_ext(Context) ->
    case maps:get(extension, Context, undefined) of
        undefined ->
            #{};
        Ext ->
            Ext
    end.

-spec get_ext(ext_name(), ctx()) ->
    binary() | undefined.
get_ext(ExtName, Context) ->
    maps:get(ExtName, maps:get(extension, Context), undefined).


-spec get_rpc_id(ctx()) ->
    woody_t:rpc_id() | no_return().
get_rpc_id(Context) ->
    do_get_rpc_id(self, Context).

-spec get_child_rpc_id(ctx()) ->
    woody_t:rpc_id() | no_return().
get_child_rpc_id(Context) ->
    do_get_rpc_id(child, Context).


-spec get_rpc_id(woody_t:dapper_id(), ctx()) ->
  woody_t:req_id() | undefined | no_return().
get_rpc_id(Key, Context) ->
    do_get_rpc_id(self, Key, Context).

-spec get_child_rpc_id(woody_t:dapper_id(), ctx()) ->
  woody_t:req_id() | undefined | no_return().
get_child_rpc_id(Key, Context) ->
    do_get_rpc_id(child, Key, Context).


-spec set_ev_handler(woody_t:handler(), woody_context:ctx()) ->
    woody_context:ctx().
set_ev_handler(EvHandler, Context) ->
    Context#{event_handler := EvHandler}.

-spec get_ev_handler(woody_context:ctx()) ->
    woody_t:handler().
get_ev_handler(#{event_handler := EvHandler}) ->
    EvHandler.


-spec make_rpc_id(woody_t:parent_id(), woody_t:trace_id(), woody_t:span_id()) ->
    woody_t:rpc_id().
make_rpc_id(ParentId, TraceId, SpanId) ->
    #{
        parent_id => ParentId,
        trace_id  => TraceId,
        span_id   => SpanId
     }.

-spec new_id(binary()) ->
    woody_t:req_id().
new_id(Suffix) when is_binary(Suffix) ->
    IdInt = unique_int(),
    IdBin = genlib:to_binary(IdInt),
    <<IdBin/binary, $:, Suffix/binary>>.

-spec unique_int() ->
    pos_integer().
unique_int() ->
    <<Id:64>> = snowflake:new(?MODULE),
    Id.

%%
%% Internal functions
%%
-spec make_ctx(is_root(), woody_t:rpc_id(), woody_t:handler(), ext() | undefined) ->
    ctx() | no_return().
make_ctx(true, #{parent_id := ParentId}, _, _) when ParentId =/= ?ROOT_REQ_PARENT_ID ->
    error({badarg, root_has_parent});
make_ctx(false, #{parent_id := undefined}, _ , _) ->
    error({badarg, orphan_child});
make_ctx(IsRoot, RpcId, EvHandler, Ext) ->
    init_ext(#{
        root_rpc      => IsRoot,
        seq           => 0,
        rpc_id        => RpcId,
        event_handler => EvHandler
    }, Ext).

init_ext(Context, undefined) ->
    Context;
init_ext(Context, Ext) ->
    Context#{extension => Ext}.

-spec do_get_rpc_id(self | child, ctx()) ->
    woody_t:rpc_id() | no_return().
do_get_rpc_id(self, #{rpc_id := RpcId}) ->
    RpcId;
do_get_rpc_id(child, #{child_rpc_id := RpcId}) ->
    RpcId;
do_get_rpc_id(_, _) ->
    error(badarg).

-spec do_get_rpc_id(self | child, woody_t:dapper_id(), ctx()) ->
  woody_t:req_id() | undefined | no_return().
do_get_rpc_id(Type, Key, Context) ->
    maps:get(Key, do_get_rpc_id(Type, Context), undefined).

-spec append_ext(ext(), map()) ->
    ext() | no_return().
append_ext(ExtBase, ExtNew) ->
    Ext = maps:merge(ExtNew, ExtBase),
    SizeSum = maps:size(ExtBase) + maps:size(ExtNew),
    case maps:size(Ext) of
        SizeSum ->
            Ext;
        _ ->
            error({badarg, extension_duplicates})
    end.
